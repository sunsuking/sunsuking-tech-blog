---
title: 레디스 디자인 패턴
category:
  - Redis
desc: 레디스에서 데이터를 저장하기 위한 디자인 패턴에 대해서 공부해보자.
thumbnail: ./images/redis.png
alt: 레디스 이미지
createdAt: 2024-04-21 22:13
updatedAt: 2024-04-21 22:13
tags:
  - Posting
  - Redis
  - DesignPattern
isFinished: true
---
## 레디스의 데이터 저장 디자인 패턴

기존의 RDBMS에서는 모든 데이터를 저장하고, 원하는 데이터를 조회할 수 있는 쿼리를 작성하여 데이터를 조회하는 방식으로 사용했다. 하지만, 레디스에서는 리소스 문제 뿐 아니라 데이터를 저장하는 방식이 RDBMS와 다르기 때문에 디자인 패턴을 고려하여 설계해야한다.

레디스에서 데이터를 저장 방식을 설계하기 전에 아래와 같은 사항을 분석하고 설계해야한다.

1. 원하는 응답을 위한 쿼리를 찾아낸다.
2. 원하는 응답을 이끌어낼 쿼리 기반으로 데이터를 저장한다.

### 레디스 디자인 패턴을 위한 고려 사항

조금 설명이 어려운데, 아래와 같이 고려 사항을 분석해보면 쉽게 설계할 수 있을 것이다.

1. 어떤 타입의 데이터를 저장해야하나?
2. 데이터의 크기를 고려해야하는가? 
3. 만료 기간을 설정해야하는 데이터인가?
4. 이름 명명 정책이 어떻게 되는가?
5. 비즈니스 로직을 고려해야하는가?

위 총 5가지를 고려해여 레디스를 설계하면 더욱 효율적으로 레디스를 사용할 수 있을 것이다.

### 이름 명명 정책이란

레디스에서는 이미 이름이 정해져있는 테이블을 사용하지 않고 `key` 와 `value` 기반의 데이터베이스이기 때문에 이름 명명 규칙을 고려하여 설계해야한다. 
레디스에서 이름 명명을 설계하기 위해서는 아래와 같은 규칙을 지키면 된다.

1. 키는 무조건 유일해야만한다.
2. 다른 개발자가 키를 보고 어떤 역할을 수행하는 키인지 이해할 수 있어야한다.
3. 콜론(:)을 사용하여 데이터의 도메인을 분리해라.
4. *데이터의 식별자(ID)의 경우 콜론 대신 파운드(#)를 사용해라.*

마지막 규칙의 경우 정석적인 방식은 아니지만, 식별자를 파운드로 구분할 경우 더욱 빠르게 검색할 수 있다는 장점이 있기에 고려해볼만한 사항이다.

## 디자인 패턴 적용 (서버사이드 렌더링 페이지 성능 개선)

### 레디스 설계 고려 사항

만약, 서버사이드 렌더링 페이지를 개발하기 위해 렌더링된 HTML을 캐싱 처리한다고 가정해보자.

1. 어떤 타입의 데이터를 저장할 것인가?
    문자열 타입의 데이터를 저장한다. 특정한 페이지의 이름을 `key` 값으로 렌더링된 HTML을 `value` 값으로 저장한다.

2. 데이터의 크기를 고려해야하는가?
	고려해야한다. 특히, 사용자마다 다른 페이지들은 캐싱 처리하게되면 서버 리소스에 무리가 가기에 오로지 로그인, 회원가입과 같은 공통 페이지만 캐싱 처리한다.

3. 만료 기간을 설정해야하는 데이터인가?
	 만료 기간을 설정해야한다. 물론, 공통 페이지의 경우 업데이트가 빈번 하지 않지만, 그럼에도 수정될 사항이 있기 때문이다.

4. 이름 명명 정책이 어떻게 되는가?
	pagecache#{routePageName}

5. 비즈니스 로직을 고려해야하는가?
	단순히 렌더링된 페이지의 결과를 캐싱하기에 필요하지 않다.

### 실제 코드로 구현

```typescript
import { pageCacheKey } from "$services/keys";
import { client } from "$services/redis";

const cacheRoutes = [
	'/about', '/privacy', '/auth/signin', '/auth/signup'
]

export const getCachedPage = (route: string) => {
	if (cacheRoutes.includes(route)) {
		return client.get(pageCacheKey(route));
	}
	return null;
};

export const setCachedPage = (route: string, page: string) => {
	if (cacheRoutes.includes(route)) {
		return client.set(pageCacheKey(route), page, {
			EX: 2
		});
	}
};
```

위 코드와 같이 작성하게 된다면 렌더링된 페이지를 캐싱할 수 있게 된다. 

- `cacheRoutes`:  배열을 사용하여 2번 고려 사항이었던 특정한 페이지만을 캐싱할 수 있도록 저장할 페이지를 설정해준다. 
- `getCachedPage`: 캐싱된 페이지로 접근하게 된다면 레디스에 저장된 데이터를 가져와주고, 저장되어 있지 않다면 `null` 값을 반환해줌으로써 캐싱 데이터를 접근할 수 있도록 설정해준다.
- `setCachedPage`: 캐싱 처리할 페이지 요청이 들어올 경우 `EX` 옵션을 사용하여 만료기간을 설정하여 캐시에 값을 담을 수 있도록 해준다.

---
## 참고 자료
